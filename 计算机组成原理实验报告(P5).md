# 计算机组成原理实验报告(P5)



## 一、 CPU设计方案综述

### （一）、总体设计概述

​        本CPU为Verilog实现的五级流水线MIPS - CPU，支持的指令集MIPS-lite2={ addu, subu, ori, lw, sw, beq, lui, j, jal, jr, nop }， 并在此基础上增加{addiu, sh, sb, lh, lb, and, or, sll}指令。为了实现这些功能CPU的设计分为三级， 第一级为流水级，包含（F级、F\D流水寄存器、D级、D\E流水寄存器、E级、E\M流水寄存器、M级、M\W流水寄存器），第二级为各流水级的内部模块，第三级为各模块的内部构造。具体的层次结构如图所示：

<img src="C:\Users\123\Desktop\computer organization\P5\层次结构.jpg" width="30%">

对于各级指令，采用分布式译码的方式，在每一级中设置独立但完全相同的Controller, 并通过采取阻塞转发机制，处理冲突和各类冒险，在保证指令执行正确性的前提下，提高效率。最后，通过自己编写的对针对各种转发机制的测试程序，验证其正确性。

**************

### （二）、关键模块定义

### 1.F级

#### 1.PC

| 名称  | I\O  | 端口大小 |      说明      |
| :---: | :--: | :------: | :------------: |
|  PC   |  O   |   31:0   |  当前指令指针  |
|  NPC  |  I   |   31:0   | 下一个指令指针 |
|  clk  |  I   |    1     |    时钟信号    |
| reset |  I   |    1     |  同步复位信号  |
| PCEnD |  I   |    1     | 指令寄存器使能 |

#### 2. NPC

| 名称  | I\O  | 端口大小 |              说明              |
| :---: | :--: | :------: | :----------------------------: |
|  PC   |  I   |   31:0   |          当前指令指针          |
| NPCOp |  I   |   1:0    | 00:PC+4, 01:beq, 10:jal, 11:jr |
|  IMM  |  I   |   25:0   |          jal 写入地址          |
|  RA   |  I   |   31:0   |          jr 跳转地址           |
|  PC4  |  O   |   31:0   |              PC+4              |
|  NPC  |  O   |   31:0   |         下一个指令指针         |

#### 3.IM

| 名称  | I\O  | 端口大小 |   说明   |
| :---: | :--: | :------: | :------: |
| Iaddr |  I   |   31:0   |  pc指针  |
| Instr |  O   |   31:0   | 当前指令 |



### 2.F\D寄存器

|    名称    | I\O  | 端口大小 |           说明            |
| :--------: | :--: | :------: | :-----------------------: |
|    clk     |  I   |    1     |         时钟信号          |
|   reset    |  I   |    1     |       同步复位信号        |
| FDEn_FD_I  |  I   |    1     |       寄存器使能端        |
| Instr_FD_I |  I   |   31:0   | FD指令输入（F级当前指令） |
|  PC_FD_I   |  I   |   31:0   |  FDpc输入（F级当前pc值）  |
|  PC_FD_O   |  O   |   31:0   |  FDpc输出（D级当前pc值）  |
| Instr_FD_O |  O   |   31:0   | FD指令输出（D级当前指令） |



### 3. D级

#### 1.GRF

| 名称 | I\O  | 端口大小 |                             说明                             |
| :--: | :--: | :------: | :----------------------------------------------------------: |
|  A1  |  I   |   4:0    |                       rs地址（25:21）                        |
|  A2  |  I   |   4:0    |                       rt地址（20:16）                        |
|  A3  |  I   |   4:0    | WR选择信号 00：rs（20:16）， 01：rd（15:10）， $ra （5'h1f） |
|  WD  |  I   |   31:0   |                           写入信号                           |
| RD1  |  O   |   31:0   |                         rs寄存器的值                         |
| RD2  |  O   |   31:0   |                         rt寄存器的值                         |

#### 2. Extender

| 名称  | I\O  | 端口大小 | 说明                                                         |
| ----- | ---- | -------- | ------------------------------------------------------------ |
| ExtOp | I    | 1:0      | 00: signed_extend 01: unsigned_extend 10: lui({in[15:0]}, {16{0}}) |
| in    | I    | 15:0     | Instr[15:0]                                                  |
| out   | O    | 32:0     | 输出结果                                                     |

#### 3.Acoder

对各个指令的AT信息进行译码

|  名称  | I\O  | 端口大小 |      说明      |
| :----: | :--: | :------: | :------------: |
| Opcode |  I   |   5:0    | Opcode选择信号 |
| Funct  |  I   |   5:0    | Funct选择信号  |
| Tusers |  O   |   2:0    |  rs的使用时间  |
| Tusert |  O   |   2:0    |  rt的时钟时间  |
|  Tnew  |  O   |   2:0    | 产生结果的时间 |

#### 

### 4.D\E寄存器

|    名称    | I\O  | 端口大小 |           说明            |
| :--------: | :--: | :------: | :-----------------------: |
|    clk     |  I   |    1     |         时钟信号          |
|   reset    |  I   |    1     |       同步复位信号        |
| Instr_DE_I |  I   |   31:0   | FD指令输入（D级当前指令） |
|  PC_DE_I   |  I   |   31:0   |  FDpc输入（D级当前pc值）  |
|  PC_DE_O   |  O   |   31:0   |  FDpc输出（E级当前pc值）  |
| Instr_DE_O |  O   |   31:0   | FD指令输出（E级当前指令） |
|  RD1_DE_I  |  I   |   31:0   |     value of rs(D级)      |
|  RD2_DE_I  |  I   |   31:0   |     value of rt(D级)      |
|  Ext_DE_I  |  I   |   31:0   |      Ext resut(D级)       |
|  RD1_DE_I  |  O   |   31:0   |     value of rs(E级)      |
|  RD2_DE_I  |  O   |   31:0   |     value of rt(E级)      |
|  Ext_DE_O  |  O   |   31:0   |      Ext resut(E级)       |
| Tnew_DE_I  |  I   |   2:0    |     冒险控制Tnew(D级)     |
| Tnew_DE_O  |  O   |   2:0    |     冒险控制Tnew(E级)     |



### 5. E级

#### 1.ALU

|    名称    | I\O  | 端口大小 |      说明       |
| :--------: | :--: | :------: | :-------------: |
|    SrcA    |  I   |   31:0   | 参与运算的A信号 |
|    SrcB    |  I   |   31:0   | 参与运算的B信号 |
|    Zero    |  O   |   31:0   |   beq相等信号   |
|   result   |  O   |   31:0   |    计算结果     |
| ALUControl |  I   |   31:0   |   ALU控制信号   |

#### 2.WD_MUX

对写入的目标寄存器进行选择  2‘b00选择rt寄存器， 2'b01选择rd寄存器 2'b10选择$31.

#### 3. ALU_SRC_MUX

对ALU的第二个输入信号进行选择，0时选择rt寄存器的值作为输入，1时选择Extender的结果作为输入.



### 6.E\M寄存器

|    名称    | I\O  | 端口大小 |           说明            |
| :--------: | :--: | :------: | :-----------------------: |
|    clk     |  I   |    1     |         时钟信号          |
|   reset    |  I   |    1     |       同步复位信号        |
| Instr_EM_I |  I   |   31:0   | EM指令输入（E级当前指令） |
|  PC_EM_I   |  I   |   31:0   |  EMpc输入（E级当前pc值）  |
|  PC_EM_O   |  O   |   31:0   |  EMpc输出（M级当前pc值）  |
| Instr_EM_O |  O   |   31:0   | EM指令输出（M级当前指令） |
| ALURS_EM_I |  I   |   31:0   |     ALU计算结果(E级)      |
|  WD_EM_I   |  I   |   31:0   |        WD结果(E级)        |
|  Dst_EM_I  |  I   |   31:0   | 可能写入的寄存器地址(E级) |
| ALURS_EM_O |  O   |   31:0   |     ALU计算结果(M级)      |
|  WD_EM_O   |  O   |   31:0   |        WD结果(M级)        |
|  Dst_EM_O  |  O   |   31:0   | 可能写入的寄存器地址(M级) |
| Tnew_EM_I  |  I   |   2:0    |     冒险控制Tnew(E级)     |
| Tnew_EM_O  |  O   |   2:0    |     冒险控制Tnew(M级)     |



### 7.M级

#### 1.  DM

| 名称  | I\O  | 端口大小 |     说明     |
| :---: | :--: | :------: | :----------: |
|  scr  |  I   |    1     |  写数据使能  |
|  sel  |  I   |    1     | RAM工作使能  |
|   A   |  I   |   4:0    |   写入地址   |
|  D1   |  I   |   31:0   |  写入的数据  |
|  D2   |  O   |   31:0   |  输出的数据  |
|  clk  |  I   |    1     |   时钟信号   |
| reset |  I   |    1     | 同步复位信号 |



### 8.M\W寄存器

|    名称    | I\O  | 端口大小 |           说明            |
| :--------: | :--: | :------: | :-----------------------: |
|    clk     |  I   |    1     |         时钟信号          |
|   reset    |  I   |    1     |       同步复位信号        |
| Instr_MW_I |  I   |   31:0   | MW指令输入（E级当前指令） |
|  PC_MW_I   |  I   |   31:0   |  MWpc输入（E级当前pc值）  |
|  PC_MW_O   |  O   |   31:0   |  MWpc输出（M级当前pc值）  |
| Instr_MW_O |  O   |   31:0   | MW指令输出（M级当前指令） |
| ALURS_MW_I |  I   |   31:0   |     ALU计算结果(M级)      |
|  RD_MW_I   |  I   |   31:0   |        WD结果(M级)        |
|  Dst_MW_I  |  I   |   31:0   | 可能写入的寄存器地址(M级) |
| ALURS_MW_O |  O   |   31:0   |     ALU计算结果(W级)      |
|  RD_MW_O   |  O   |   31:0   |        WD结果(W级)        |
|  Dst_MW_O  |  O   |   31:0   | 可能写入的寄存器地址(W级) |
| Tnew_MW_I  |  I   |   2:0    |     冒险控制Tnew(M级)     |
| Tnew_MW_O  |  O   |   2:0    |     冒险控制Tnew(W级)     |



### 9.W级

#### 1.LTC

|  名称  | I\O  | 端口大小 |                说明                |
| :----: | :--: | :------: | :--------------------------------: |
|  addr  |  I   |   31:0   | 读取的地址（根据最后两位判断指令） |
| M_type |  I   |   1:0    |            Load选择信号            |
|  Din   |  I   |   31:0   |           原始数据（1w）           |
|  Dout  |  I   |   31:0   |     选择后的数据（lw, lh, lb）     |

#### 2. WDMUX

对写回GRF的数据进行选择 2'b00选择由ALU直接产生的结果， 2'b01选择从DM中读取的数据，2'b01写入PC值（PC+8）.



### 10. Controller

对于每一级中均独立存在的Controller,其控制信号的组合逻辑如下

|  名称  | I\O  | 端口大小 |     说明     |
| :----: | :--: | :------: | :----------: |
| Opcode |  I   |   5:0    |  opcode字段  |
|  Func  |  I   |   4:0    | function字段 |

控制信号及对应的指令如下：

|               Instru                | Opcode | RFWr | WRSel | WDSel | ALU_SrcSel | DMWr |   ALUOp    | NPCOp | ExtOp | M_type |
| :---------------------------------: | :----: | :--: | :---: | :---: | :--------: | :--: | :--------: | :---: | :---: | :----: |
| R_type（or and addu subu sll sllv） | 000000 |  1   |  01   |  00   |     0      |  0   | ALUControl |  00   |   x   |   00   |
|                 ori                 | 001101 |  1   |  00   |  00   |     1      |  0   |    011     |  00   |  01   |   00   |
|                 lw                  | 100011 |  1   |  00   |  01   |     1      |  0   |    000     |  00   |  00   |   11   |
|                 lh                  | 100001 |  1   |  00   |  01   |     1      |  0   |    000     |  00   |  00   |   10   |
|                 lb                  | 100000 |  1   |  00   |  01   |     1      |  0   |    000     |  00   |  00   |   01   |
|                 sw                  | 101011 |  0   |   x   |  00   |     1      |  1   |    000     |  00   |  00   |   11   |
|                 sh                  | 101001 |  0   |   x   |  00   |     1      |  1   |    000     |  00   |  00   |   10   |
|                 sb                  | 101000 |  0   |   x   |  00   |     1      |  1   |    000     |  00   |  00   |   01   |
|                 beq                 | 000100 |  0   |   x   |  00   |     0      |  0   |    001     |  01   |   x   |   00   |
|                 lui                 | 001111 |  1   |  00   |  00   |     1      |  0   |    000     |  00   |  10   |   00   |
|                addiu                | 001001 |  1   |  00   |  00   |     1      |  0   |    000     |  00   |  00   |   00   |
|                 jal                 | 000011 |  1   |  10   |  10   |     x      |  0   |    000     |  10   |   x   |   00   |
|                 jr                  | 000000 |  0   |   x   |  11   |     x      |  0   |    000     |  11   |   x   |   00   |
|                  j                  | 000010 |  0   |   x   |  00   |     x      |  x   |    000     |  10   |   x   |   00   |



### （二）冒险控制

在本次CPU设计中，由于哈佛体系下DM,IM的分离，不存在结构冒险，对于跳转冒险，由于仅包含beq这一由寄存器的值决定是否发生跳转的指令，故将跳转指令的冒险归入数据冒险之中。

使用D级中的ACoder部件，各指令AT信息译码：

| 指令                      | 使用寄存器编号 | 写入寄存器编号 | Tuse        | Tnew |
| ------------------------- | -------------- | -------------- | ----------- | ---- |
| addu\subu\or\and\sll\sllv | rs,rt          | rd             | 1           | 2    |
| load(lw,lh,lb)            | rs             | rt             | 1           | 3    |
| sw(sw,sh,sb)              | rs,rt          | /              | (rs)1,(rt)2 | 0    |
| lui                       | /              | rt             | /           | 2    |
| ori                       | /              | rt             | /           | 2    |
| beq                       | rs,rt          | /              | 0           | /    |
| jr                        | rs             | /              | 0           | /    |
| jal                       | /              | $31            | /           | 3    |
| addiu                     | rs             | rt             | 1           | 2    |

对于AT信息的控制

通过RiskCtrl部件对冒险进行控制



## 二、测试方案

### 1.正确性检验

设计的测试程序方案如下：

<img src="C:\Users\123\Desktop\computer organization\P5\转发示意图.jpg" width="1000%">



如图，本次设计的CPU有三个接受转发点，记为A,B,C点，有两个提供转发数据点，记作M,W点，故可以产生AM,AW,BM,BW,CW共五种路径的转发（不存在CW路径），继而考虑每条路径上有两条路，则共有9条路需要进行单独测试，此外，还需考虑多路转发条件均成立时选择的优先级是否正确，因此需要进一步考虑  AM,AW同时成立的数据转发，BM,BW同时成立的数据转发，在每一种类别中充分测试各个指令以及$zero的特判），即可对转发和暂停的冒险控制的正确性进行强度较高的测试。

```python
lui $t3, 10
sw $t3, 0($0)
sw $t3, 4($0)

#BM转发测试_rs
ori $t1, $t1, 1
addu $t1, $t1, $t2
nop
addiu $t2, $t2, 1
subu $t2, $t2, $t3
nop
lui $t1,  1
addu $t1, $t1, $t2
nop
subu $t1, $t2, $t2
subu $t1, $t1, $t2
nop
subu $t1, $t1, $t1
ori $t1, $t1, 1
nop
subu $t2, $t2, 0
subu $t2, $t2, $t1
nop
subu $t3, $t2, $t1
subu $t2, $t3, $t1
nop
addu $t3, $t2, $t3
addu $t3, $t3, $t2
nop
lw $t2, 4($0)
addu $t3, $t2, $t1
nop

#BM转发测试_rt
ori $t1, $t1, 1
addu $t1, $t2, $t1
nop
addiu $t2, $t2, 1
subu $t2, $t3, $t2
nop
lui $t1,  1
addu $t1, $t3, $1
nop
subu $t1, $t2, $t2
subu $t1, $t1, $t1
nop
subu $t1, $t1, $t1
ori $t1, $t1, 1
nop
subu $t2, $t2, 0
subu $t2, $t3, $t2
nop
subu $t3, $t2, $t1
subu $t2, $t4, $t3
nop
addu $t3, $t2, $t3
addu $t3, $t1, $t3
nop
lw $t2, 4($0)
addu $t3, $t1, $t2
nop

#BW转发测试_rs
addiu $t1, $t1, 1
nop
lui $t1,  45
nop
lw $t3, 0($0)
nop
addiu $t3, $t3, 2
ori $t1, $t1, 1
nop
addu $t1, $t1, $t1
nop
subu $t1, $t1, $t3
nop
and $t1, $t1, $t2
nop
addu $t3, $t1, $t2

#BW转发测试_rt
addiu $t1, $t1, 1
nop
lui $t1,  45
nop
lw $t3, 0($0)
nop
addiu $t3, $t3, 2
ori $t1, $t1, 1
nop
addu $t1, $t1, $t1
nop
subu $t1, $t3, $t1
nop
and $t3, $t2, $1
nop
addu $t3, $t1, $t3

#BW与BM转发的优先顺序测试_rs
ori $t3, 1
ori $t2, 2
addu $t2, $t2, $t2
subu $t4, $t2, $t3
addiu $t4, $t4, -1
addu $t4, $t4, $t2
or $t1, $t4, $t2
subu $t5, $t1, $t2

#BW与BM转发的优先顺序测试_rt
ori $t3, 4
ori $t2, 5
addu $t2, $t2, $t2
subu $t4, $t3, $t2
addiu $t4, $t4, -1
addu $t4, $t4, $t2
addiu $t4, $t4, -1
addu $t4, $t3, $t4
or $t1, $t5, $t4
subu $t5, $t2, $t1

#beq (AM)测试_rs
ori $t6, $t6, 1
ori $t7, $t7, 1
beq $t6, $t7, label
nop
jal num
label:
addu $t1, $t1, $t1
beq $t1, $t1, nobe
nop
num:
addu $t1, $t1, $t1
jr $ra
nop
nobe:

#beq(AW)测试_rt
and $t6, $t6, $0
ori $t6, 4
sw $t6, 16($0)
lw $t1, 16($0)
ori $t7, $t7, 4
beq $t1, $t7 right2
nop
addiu $t7, $t7, 2
right2:
sw $t7, 0($0)
lw $t7, 4($0)

#beq(AM与AW的优先顺序测试)_rs
and $t6, $t6, $0
ori $t5, 5
ori $t6, 6
addiu $t6, $t6, -1
beq $t6, $t5, right_seq1
nop
addiu $t7, $t7, 2
right_seq1:
sw $t7, 0($0)

#beq(AM与AW的优先顺序测试)_rt
and $t6, $t6, $0
ori $t5, 5
ori $t6, 6
addiu $t6, $t6, -1
beq $t5, $t6, right_seq2
nop
addiu $t7, $t7, 2
right_seq2:
sw $t7, 0($0)

# CW指令测试
ori $t2, $t2, 3
sw $t2, 16($0)
lw $t3, 16($0)
sw $t3, 20($0)
and $t2, $t2, $0
addiu $t2, $t2, 4
sw $t2, 0($0)
lw $t2, 0($0)
sw $t3, 0($t2)

# jal & j 测试
jal fun
nop
ori $30, $30, 2
jal fun2
nop
addiu $t4, $t3, 1
j end
nop

fun:
ori $30, $30, 1
jr $ra
nop

fun2:
addiu $t2, $t2, 1
sll $t2, $t2, 1
and $t2, $t2, $t3
or $t2, $t3, $t2
jr $ra
nop

# 跳转指令及延迟槽测试
and $t1, $t1, $0
ori $t1, $t1, 100
jal funct
addiu $ra, $ra, 4
addiu $t1, $t1, 2
j end
nop

funct:
sw $t2, 0($0)
jr $ra
nop

end:

```

使用自制的测评级对结果进行校对（测评机代码详见附录），检验设计CPU转发控制的正确性。



### 2.效率检验（正确的暂停机制）

在保证正确性的前提下，还需要考虑执行的效率，故设计了如下的测试程序，该程序设计时在认为设计正确的情况下不会出现暂停，若出现多余的暂停，则可以认为暂停的机制出现了问题，可以通过查看仿真波形的stall信号来确定，而前一步的正确性检验已经检验CPU的正确性，故而无需考虑不应该出现暂停的地方发生暂停的情况。

```python
# 暂停机制测试
and $t2, $t2, $0
ori $t2, $t2, 2
lw $t1, 0($0)
nop
nop
beq $t1, $t2, jump
nop
ori $t3, $t3, 100
jump:
addu $t2, $t2, $t2
addu $t1, $t1, $t1
nop
beq $t1, $t2, jump2
nop
ori $t4, $t4, 100
jump2:
    
and $t1, $t1, $0
ori $t1, $t1, 100
jal funct
addiu $ra, $ra, 4
addiu $t1, $t1, 2
j end
nop

funct:
sw $t2, 0($0)
jr $ra
nop

end:  
```



## 三、思考题



### 1.流水线冒险

#### 1.在采用本节所述的控制冒险处理方式下，PC的值应当如何被更新？请从数据通路和控制信号两方面进行说明。

正常工作时，F级PC每个周期变为PC+4，PC信号在数据通路中的每一级进行流水，并在W级将PC+8的值作为WD_MUX的一个选择；当stall信号为高电平时,F级PC寄存器处于没有enable的状态，PC的值保持不变。当NPCOp信号分别为跳转指令beq，j，jal时，相应地跳转为约定值。

#### 2.对于jal等需要将指令地址写入寄存器的指令，为什么需要回写PC+8？

为了提高工作效率，流水线CPU中将跳转指令的下一条指令设置为将在PC跳转（jal写入$31寄存器）时执行的指令，称为“延迟槽”，当需要跳转到$ra(或其他指定寄存器)存储的地址时延迟槽中的指令应该被跳过，从j指令所在的地址+8处执行。因此应写回PC+8



### 2.数据冒险的分析

#### 为什么所有的供给者都是存储了上一级传来的各种数据的**流水级寄存器**，而不是由ALU或者DM等部件来提供数据？

每两个流水寄存器间的组合或是时序电路均存在延迟，若从此处转发，其实际时间延迟将是这两级组合逻辑电路的总和，且不稳定。而上一级流水线寄存器的值可以认为是在时钟上升沿就立即发生变化。可以认为来源于流水级寄存器的数据更加稳定，因此以他们作为供给者相较于前者更加系统和稳定，更有利于提高CPU主频。



### 3.AT法处理流水线数据冒险

#### 1.“转发（旁路）机制的构造”中的Thinking 1-4：

**Thinking 1**：为了实现转发机制，我们对这些输入前加上一个MUX。这些MUX的默认输入来源是上一级中已经转发过的数据。如果不采用已经转发过的数据，而采用上一级中的原始数据，会出现怎样的问题？试列举指令序列说明这个问题。

比如对于如下的指令序列：

```python
addiu $t1, $t1, 1
nop
nop
subu $t1, $t1, $t1
addu $t3, $t1, $t2
```

addu进行计算时，使用从GPR中读取的$t1的值为1，(subu尚未将计算结果写回$t1)，将会产生错误。



**Thinking 2**：我们为什么要对GPR采用内部转发机制？如果不采用内部转发机制，我们要怎样才能解决这种情况下的转发需求呢？

GPR可视作W级后的一个流水级寄存器，进入GPR的数据是W级的一部分，从GPR中输出的数据归属W的下一级，两者之前可能存在数据冒险因而需要转发， 具体而言，当WA地址与A1,A2中的地址相同且写使能为高电平时，意味着将会出现数据还未写入寄存器而读出寄存器的值未被更新的数据冒险。此时可以通过内部转发机制：当WA地址与A1,A2中的地址相同且写使能为高电平时读出寄存器的值直接使用将要写入该寄存器的值，即可在GPR内部实现转发。若不采用这种方法，则需要在后部beq冒险的转发MUX上新增一路从W级写出的信号，并设置优先级为低于M级转发信号，高于原始信号，当DstW与A1（或A2）相等不为0 且写使能为高电平时，选择该转发信号作为最后的输出信号。



**Thinking 3**：选择信号的生成规则是：只要当前位点的读取寄存器地址和某转发输入来源的写入寄存器地址相等且不为0，为什么0号寄存器需要特殊处理？

MIPS中，0号寄存器的值恒定为0，故实际上写入0号寄存器的值都不需要转发，转发反而导致错误的产生，因此0号寄存器需要特殊处理。



**Thinking 4**：什么是“最新产生的数据”？

比如对于如下的指令序列

```python
ori $t2, $t2, 2
ori $t1, $t1, 1
addu $t1, $t1, $t1
beq $t1, $t2, label
```

该指令序列在CPU中执行时，当beq指令流水到D级时，$t1 的流水信号在EM寄存器中为2，在MW寄存器中为1，此时就产生了应该在这两个信号中选择哪一个进行转发的问题。而正确的选择正如这段代码序列的程序员逻辑一样，使用$t1前，最后更改$t1的值的指令产生的$t1 的值即为需要转发的值，即使用“最新产生的数据”。对应于本次设计的CPU，即为M级的转发信号优于W级。



#### 2.在AT方法讨论转发条件的时候，只提到了“供给者需求者的A相同，且不为0”，但在CPU写入GRF的时候，是有一个we信号来控制是否要写入的。为何在AT方法中不需要特判we呢？为了**用且仅用**A和T完成转发，在翻译出A的时候，要结合we做什么操作呢？

在翻译出来A时， 如果该指令确实需要将值写入目标寄存器，则可将A翻译为相应的地址，而不会写入时，则将A设置为0,故“且不为0”的条件就可以保证转发不会错误地发生。













































## 四、附录——辅助测试工具代码

主程序代码：

```python
import subprocess
import os
from shutil import copyfile

# initialize path setting
path = "C:\\Users\\123\\Desktop\\computer organization\\test_tool3.0\\"
testfile = "test.asm"

# get code and standard output from mars(modified)
os.chdir(path)
os.system("java -jar Mars.jar nc mc CompactDataAtZero dump .text HexText code.txt >ans.txt " + testfile)
copyfile((path+"code.txt"), (path+"source\\code.txt"))
copyfile((path+"ans.txt"), (path+"report\\stdans.txt"))

# execute run.bat and get test output from I_verilog
os.chdir(path+"source")
filepath = path+"source\\run.bat"
p = subprocess.Popen(filepath, shell=True, stdout=subprocess.PIPE)
stdout, stderr = p.communicate()
copyfile(path+"source\\myout.txt", path+"report\\myans.txt")

# compare two results and give feedback
os.chdir(path+"report")
std = open("stdans.txt", "r")
test = open("myans.txt", "r")
tlin_r = test.readline()
i = 0
while True:
    i = i + 1
    slin = std.readline()
    while slin[11:14] == "$ 0":
        slin = std.readline()
    tlin_r = test.readline()
    if len(tlin_r) > 20:
        tlin = tlin_r[20:-1] + tlin_r[-1]
    else:
        tlin = tlin_r
    if not tlin and slin == "\n":
        print("Accepted!")
        break
    elif not tlin:
        print("The answer is fewer than standard. We got nothing when we expect: ‘"+slin[0:-1]+"’ at line "+str(i))
        break
    elif not slin:
        print("The answer is too much. We got '"+tlin+"' when we expect nothing")
        break
    elif slin != tlin:
        slin_next = std.readline()
        tlin_next_r = test.readline()
        if len(tlin_next_r) < 22:
            continue
        tlin_next = tlin_next_r[20:-1] + tlin_next_r[-1]
        if slin_next == tlin and tlin_next == slin:
            i = i + 1
            pass
        else:
            print("Wrong Answer! We got ‘"+tlin[0:-1]+"’ when we expect: ‘"+slin[0:-1]+"’ at line "+str(i))
            break
    else:
        pass

print("detailed information has been generated in report document")
input("     exit when press anything")

```

iverilog执行的批处理bat代码：

```cmd
set iverilog_path=C:\iverilog\bin;
set gtkwave_path=C:\iverilog\gtkwave\bin;
set path=%iverilog_path%%gtkwave_path%%path%

iverilog -o "test_bench.vvp" "test_bench.v" "NPC.v" "PC.v" "Controller.v" "ALU.v" "Extender.v" "LTC.v" "GRF.v" "IM.v" "mips.v" "DM.v" "ACoder.v" "D.v" "F.v" "E.v" "M.v" "W.v" "EMReg.v" "DEReg.v" "MWReg.v" "RiskCtrl.v" "FDReg.v"

(vvp -n "test_bench.vvp")> myout.txt
```





