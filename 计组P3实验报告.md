# 计算机组成原理实验报告(P3)



## 一、 CPU设计方案综述



### （一）、总体设计概述

​     本CPU为logisim实现的单周期MIPS - CPU，支持的指令集包含{addu、subu、or、lw、sw、j、and、addi、lui、ori、beq、nop}。为了实现这些功能，CPU主要包含了NPC、GRF、ALU、DM、Controller，这些模块组成的CPU分为两级。



**************



### （二）、关键模块定义

#### 1. NPC

| 名称  | I\O  | 端口大小 |              说明              |
| :---: | :--: | :------: | :----------------------------: |
|  PC   |  I   |   31:0   |          当前指令指针          |
| NPCOp |  I   |   1:0    | 00:PC+4, 01:beq, 10:jal, 11:jr |
|  IMM  |  I   |   25:0   |          jal 写入地址          |
|  RA   |  I   |   31:0   |          jr 跳转地址           |
|  PC4  |  O   |   31:0   |              PC+4              |

#### 2.GRF

| 名称 | I\O  | 端口大小 |                             说明                             |
| :--: | :--: | :------: | :----------------------------------------------------------: |
|  A1  |  I   |   4:0    |                       rs地址（25:21）                        |
|  A2  |  I   |   4:0    |                       rt地址（20:16）                        |
|  A3  |  I   |   4:0    | WR选择信号 00：rs（20:16）， 01：rd（15:10）， $ra （5'h1f） |
|  WD  |  I   |   31:0   |                           写入信号                           |
| RD1  |  O   |   31:0   |                         rs寄存器的值                         |
| RD2  |  O   |   31:0   |                         rt寄存器的值                         |



#### 3.ALU

|    名称    | I\O  | 端口大小 |      说明       |
| :--------: | :--: | :------: | :-------------: |
|    SrcA    |  I   |   31:0   | 参与运算的A信号 |
|    SrcB    |  I   |   31:0   | 参与运算的B信号 |
|    Zero    |  O   |   31:0   |   beq相等信号   |
|   result   |  O   |   31:0   |    计算结果     |
| ALUControl |  I   |   31:0   |   ALU控制信号   |



#### 4.  DM

为了更方便查看结果，将RAM独立出来作为DM

| 名称  | I\O  | 端口大小 |     说明     |
| :---: | :--: | :------: | :----------: |
|  scr  |  I   |    1     |  写数据使能  |
|  sel  |  I   |    1     | RAM工作使能  |
|   A   |  I   |   4:0    |   写入地址   |
|  D1   |  I   |   31:0   |  写入的数据  |
|  D2   |  O   |   31:0   |  输出的数据  |
|  clk  |  I   |    1     |   时钟信号   |
| reset |  I   |    1     | 同步复位信号 |

#### 5. Extender

| 名称  | I\O  | 端口大小 | 说明                                                         |
| ----- | ---- | -------- | ------------------------------------------------------------ |
| ExtOp | I    | 1:0      | 00: signed_extend 01: unsigned_extend 10: lui({in[15:0]}, {16{0}}) |
| in    | I    | 15:0     | Instr[15:0]                                                  |
| out   | O    | 32:0     | 输出结果                                                     |

#### 6.Controller

| 名称   | I\O  | 端口大小 | 说明         |
| ------ | ---- | -------- | ------------ |
| Opcode | I    | 5:0      | opcode字段   |
| Func   | I    | 4:0      | function字段 |

|    Instru     | Opcode | RegWrite | WRSel | WDSel | ALUSrc | MemWrite | ALUOp | NPCOp | ExtOp |
| :-----------: | :----: | :------: | :---: | :---: | :----: | :------: | :---: | :---: | :---: |
|    R_type     | 000000 |    1     |  01   |  00   |   0    |    0     |  010  |  00   |   x   |
|      lui      | 001111 |    1     |  00   |  00   |   1    |    0     |  000  |  00   |  10   |
|      ori      | 001101 |    1     |  00   |  00   |   1    |    0     |  011  |  00   |  01   |
|     slti      | 001010 |    1     |  00   |  00   |   1    |    0     |  110  |  00   |  00   |
|     addiu     | 001001 |    1     |  00   |  00   |   1    |    0     |  000  |  00   |  00   |
|      lw       | 100011 |    1     |  00   |  01   |   1    |    0     |  000  |  00   |  00   |
|      lb       | 100000 |    1     |   x   |  01   |   1    |    0     |  000  |  00   |  00   |
|      sw       | 101011 |    0     |   x   |  00   |   1    |    1     |  000  |  00   |  00   |
|      sb       | 101000 |    0     |   x   |  00   |   1    |    1     |  000  |  00   |  00   |
|      beq      | 000100 |    0     |   x   |  00   |   0    |    0     |  001  |  01   |   x   |
|      jal      | 000011 |    1     |  10   |  10   |   x    |    0     |  000  |  10   |   x   |
|      jr       | 000000 |    0     |   x   |  00   |   x    |    0     |  000  |  11   |   x   |
|       j       | 000010 |    0     |   x   |  00   |   x    |    x     |  000  |  10   |   x   |
| jalr(special) | 000000 |    1     |  01   |  10   |   0    |    0     |  000  |  11   |   x   |



对于ALUConroll信号，由ALUOp和Func两部分信号决定，当ALUOp不为010时，ALUControl仅有ALUOp信号决定。

当ALUOp信号为010时， 可确定为R类指令，对应的ALUControl信号将由Func信号决定，具体如下：

|     Func      |   ALUControl   |
| :-----------: | :------------: |
| 100111(addiu) | 000（加运算）  |
| 100101(subu)  | 001（减运算）  |
|  100010(and)  | 010（与运算）  |
|  100011(or)   | 011（或运算）  |
| 000100(sllv)  |  100（sllv）   |
|  000000(sll)  |   101（sll）   |
|  101010(slt)  | 110(slt, slti) |

****************



### （三）重要机制实现方法

#### 1. 跳转

本次实验具体选择在NPC中实现 J 指令与 beq 指令的跳转

由Controller综合出的Branch信号与Jump信号对下一个PC的值进行选择（通过MUX实现）

| Branch | Jump |                         NPC                          |
| :----: | :--: | :--------------------------------------------------: |
|   0    |  0   |                        PC + 4                        |
|   1    |  0   | PC + {16{offset[15]}, offset[15:0]} << 2 ( beq 指令) |
|   0    |  1   |   PC + {PC[31:28], indexp[25:0], 2{0}}  ( j 指令)    |
|   1    |  1   |                     $rd(jr指令)                      |



********



## 二、测试方案

### （一 ）典型样例测试



#### 1. ALU与DM功能测试

使用如下的Python脚本对ALU和DM的功能进行测试，并将mars的运行结果与实验设计的CPU进行比较。

```python
import os
import re
import random

# 测试ALU与DM
with open("ALU_DM.asm", "w") as file:
    for i in range(1, 6):
        num = random.randint(0, 10000)
        file.write("addi $t%d, $t%d, %d\n" % (i, i, num))
        file.write("addu $t%d, $t%d, $t%d\n" % (i, i, i))
        file.write("sw $t%d, %d($0)\n" % (i, 8*i))
        file.write("and $t%d, $t%d, $t%d\n" % (i, i+1, i))
        file.write("or $t%d, $t%d, $t%d\n" % (i, i-1, i))
        file.write("sw $t%d, %d($0)\n" % (i, 8*i+4))

os.system("java -jar mars4_5.jar ALU_DM.asm nc mc CompactTextAtZero a dump .text HexText rom.txt")

with open("rom.txt", "r") as file:
    content = file.read()
with open("P30.circ", "r") as file:
    circmy = file.read()
circmy = re.sub(r'addr/data: 5 32([\s\S]*)</a>', "addr/data: 5 32\n"+content+"</a>", circmy)
with open("test(alu).circ", "w") as file:
    circmy = file.write(circmy)
```



#### 2. 跳转指令与DM功能测试

类似地，运用同样的方法对跳转指令进行测试，并将mars的运行结果与实验设计的CPU进行比较。

```python
import os
import re
import random

# 测试 beq 指令 与 j指令
with open("Branch_DM.asm", "w") as file:
    for i in range(1, 6):
        num = random.randint(0, 10000)
        file.write("addi $t%d, $t%d, %d\n" % (i, i, num))
        file.write("addu $t%d, $t%d, $t%d\n" % (i, i, i))
        file.write("sw $t%d, %d($0)\n" % (i, 8*i))
        file.write("beq $t1, $t1, label%d\n" % i)
        file.write("and $t%d, $t%d, $t%d\n" % (i, i+1, i))
        file.write("label%d:\n" % i)
        file.write("or $t%d, $t%d, $t%d\n" % (i, i-1, i))
        file.write("sw $t%d, %d($0)\n" % (i, 8*i+4))

os.system("java -jar mars4_5.jar Branch_DM.asm nc mc CompactTextAtZero a dump .text HexText rom.txt")

with open("rom.txt", "r") as file:
    content = file.read()
with open("P30.circ", "r") as file:
    circmy = file.read()
circmy = re.sub(r'addr/data: 5 32([\s\S]*)</a>', "addr/data: 5 32\n"+content+"</a>", circmy)
with open("test(branch).circ", "w") as file:
    circmy = file.write(circmy)
```

*****



### （二）综合程序测试

​     使用如下MIPS程序（循环计算斐波那契数列和读取存储完成计算修改）进行检验，并将DM中存储的数据与Mars存储区的数据进行比对：
```python
loop:                  #使程序循环运行
subu $t0, $t0, $t0     #初始化寄存器（循环一次后清零）
subu $s1, $s1, $s1
subu $t1, $t1, $t1
subu $t3, $t3, $t3
addi $s0, $0, 40
addi $t2, $t0, 1
for1_begin:
beq $t0, $s0, for1_end
nop
addu $t3, $t2, $0
addu $t2 $t2, $t1
addu $t1, $t3, $0
sw $t2, 0($t0)         #计算Fibonacci数并存入DataMemory
addi $t0, $t0, 4
j for1_begin
nop
for1_end:
subu $t0, $t0, $t0
lui $s1, 65535         #测试lui（$s1 = 0xffff0000）
addi $s1, $s1, 65534   # $s1 = 0xfffffffe
for2_begin:
beq $t0 , $s0, for2_end
nop
lw $t1, 0($t0)
lui $t2, 256
ori $t1, $t1, 256
or $t1, $t1, $t2       # 测试 or
and $t1, $t1, $s1      # 测试 and
sw $t1, 40($t0)
addi $t0, $t0, 4
j for2_begin
nop
for2_end:
j loop                 # 返回代码起始位置

```

该程序包含了本次设计的CPU所有支持的指令， 测试结果与Mars的标准结果相同。



*****



## 三、思考题



#### 1. 现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

​        合理， IM每次存入简单的程序指令时， 都是手动将外部的包含特定标题的txt文档导入数据，或者手动在修改数据时进行复制粘贴。 完成后就不再更改，无需清零或在程序运行过程中进行修改，因此，选用只读存储器ROM更加合适； 对于DM，作为数据存储区，要求既能向其中写入数据，又能从中读取数据到寄存器，选择ROM就不再合适了。 再者， DM本身模拟真实工作的CPU在写入数据时对应的一段连续的内存空间（内存），其写入速度较寄存器更慢，且不想寄存器那样具有一个一个的独立性而是存在于一段连续的堆空间中。故使用RAM更加合适； 对于GRF，我们设计的CPU仅支持MIPS指令架构， GRF中的32个寄存器恰好与MIPS架构中的32个寄存器构成一一对应关系，不仅如此，在现实中，由寄存器构成的高速缓存是CPU通过ALU完成高速运算的关键，寄存器的读写速度显著高于DM所使用的RAM，故在logisim模拟时，使用Register更加合适。

*****



#### 2. 事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由。

​      在nop指令在执行的这个单时钟周期中，CPU的除了pc寄存器之外的所有状态（GRF、DM、IM中存储的值）均不改变，要达成这一目标， 即使不将nop指令加入控制信号真值表， 由于其Opcode为000000，因而可将其看做R型指令，故不会改变DM中存储的数据。 且修改的目标寄存器rd为$0, 故实际上也不会改变GRF中的值。 CPU在此时钟周期中，仅完成了PC+4的转变，其余状态保持不变，与nop指令的实际作用相同。因此，实现nop空指令时我们并不需要将它加入控制信号真值表。

********



#### 3. 上文提到，MARS不能导出PC与DM起始地址均为0的机器码。实际上，可以通过为DM增添片选信号，来避免手工修改的麻烦，请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。

​    在本实验中，Mars代码段从0x00003000开始，而实验的CPU从0x0000000开始。这一差别使得不使用相对指令（如j、jal等指令）需要修改，故在执行 j，jal 等指令时，需要在NPC中，将所读的地址立即数减去0x3000再进行运算； 而对于使用相对指令的（如beq指令）并不需要修改。对于DM， Mars的数据段和实验中都从0x00000000开始，因此除了（sb, lb, lh, sh）指令之外，可以直接将实际地址信号左移两位作为实验CPU的地址选择信号。

***********



#### 4. 除了编写程序进行测试外，还有一种验证CPU设计正确性的办法——形式验证。 **形式验证**的含义是根据某个或某些形式规范或属性，使用数学的方法证明其正确性或非正确性。请搜索“形式验证（Formal Verification)”了解相关内容后，简要阐述相比于测试，形式验证的优劣之处。

优点：形式验证无需模拟测试，可以在更短的时间内完成完备的测试（不像程序测试那样不完备的测试具有概率性，而要追求完备需要穷举所有的可能）；快速发现模拟测试难以发现的边角处的逻辑漏洞甚至错误；无需开发测试环境，即在进行程序模拟测试前，通过快速的形式验证可以快速发现问题，减少人力物力的消耗。

缺点：在进行形式检验前我们将设定一系列的标准，通过比较电路的逻辑表达式与这些标准进行检验。但将无法仿真时序电路中的动态行为。且由于检验成本随着电路规模指数爆炸，只被限制在模块级的检验，而无法或难以进行系统级检验。



