# 计算机组成原理实验报告(P4)



## 一、 CPU设计方案综述



### （一）、总体设计概述

​     

本CPU为Verilog实现的单周期MIPS - CPU，支持的指令集包含{addu、subu、or、lw、sw、j、jal、and、addiu、lui、ori、beq、nop}。为了实现这些功能，CPU主要包含了PC、NPC、GRF、ALU、DM、Controller，这些模块组成的CPU分为两级。为了对CPU的正确性进行测试，自己设计了一个辅助测试的工具（将修改过的Mars产生输出的指令与Iverilog仿真产生的结果进行比较）并设计了测试程序进行测试，以验证所设计CPU的正确性。

**************



### （二）、关键模块定义



#### 1. NPC

| 名称  | I\O  | 端口大小 |              说明              |
| :---: | :--: | :------: | :----------------------------: |
|  PC   |  I   |   31:0   |          当前指令指针          |
| NPCOp |  I   |   1:0    | 00:PC+4, 01:beq, 10:jal, 11:jr |
|  IMM  |  I   |   25:0   |          jal 写入地址          |
|  RA   |  I   |   31:0   |          jr 跳转地址           |
|  PC4  |  O   |   31:0   |              PC+4              |

#### 2.GRF

| 名称 | I\O  | 端口大小 |                             说明                             |
| :--: | :--: | :------: | :----------------------------------------------------------: |
|  A1  |  I   |   4:0    |                       rs地址（25:21）                        |
|  A2  |  I   |   4:0    |                       rt地址（20:16）                        |
|  A3  |  I   |   4:0    | WR选择信号 00：rs（20:16）， 01：rd（15:10）， $ra （5'h1f） |
|  WD  |  I   |   31:0   |                           写入信号                           |
| RD1  |  O   |   31:0   |                         rs寄存器的值                         |
| RD2  |  O   |   31:0   |                         rt寄存器的值                         |



#### 3.ALU

|    名称    | I\O  | 端口大小 |      说明       |
| :--------: | :--: | :------: | :-------------: |
|    SrcA    |  I   |   31:0   | 参与运算的A信号 |
|    SrcB    |  I   |   31:0   | 参与运算的B信号 |
|    Zero    |  O   |   31:0   |   beq相等信号   |
|   result   |  O   |   31:0   |    计算结果     |
| ALUControl |  I   |   31:0   |   ALU控制信号   |



#### 4.  DM

| 名称  | I\O  | 端口大小 |     说明     |
| :---: | :--: | :------: | :----------: |
|  scr  |  I   |    1     |  写数据使能  |
|  sel  |  I   |    1     | RAM工作使能  |
|   A   |  I   |   4:0    |   写入地址   |
|  D1   |  I   |   31:0   |  写入的数据  |
|  D2   |  O   |   31:0   |  输出的数据  |
|  clk  |  I   |    1     |   时钟信号   |
| reset |  I   |    1     | 同步复位信号 |

#### 5. Extender

| 名称  | I\O  | 端口大小 | 说明                                                         |
| ----- | ---- | -------- | ------------------------------------------------------------ |
| ExtOp | I    | 1:0      | 00: signed_extend 01: unsigned_extend 10: lui({in[15:0]}, {16{0}}) |
| in    | I    | 15:0     | Instr[15:0]                                                  |
| out   | O    | 32:0     | 输出结果                                                     |

#### 6.Controller

| 名称   | I\O  | 端口大小 | 说明         |
| ------ | ---- | -------- | ------------ |
| Opcode | I    | 5:0      | opcode字段   |
| Func   | I    | 4:0      | function字段 |

控制信号及对应的指令如下：

| Instru | Opcode | RegWrite | WRSel | WDSel | ALUSrc | MemWrite | ALUOp | NPCOp | ExtOp |
| :----: | :----: | :------: | :---: | :---: | :----: | :------: | :---: | :---: | :---: |
| R_type | 000000 |    1     |  01   |  00   |   0    |    0     |  10   |  00   |   x   |
|  ori   | 001101 |    1     |  00   |  00   |   1    |    0     |  11   |  00   |  01   |
|   lw   | 100011 |    1     |  00   |  01   |   1    |    0     |  00   |  00   |  00   |
|   sw   | 101011 |    0     |   x   |  00   |   1    |    1     |  00   |  00   |  00   |
|  beq   | 000100 |    0     |   x   |  00   |   0    |    0     |  01   |  01   |   x   |
|  lui   | 001111 |    1     |  00   |  00   |   1    |    0     |  00   |  00   |  10   |
| addiu  | 001001 |    1     |  00   |  00   |   1    |    0     |  00   |  00   |  00   |
|  jal   | 000011 |    1     |  10   |  10   |   x    |    0     |  00   |  10   |   x   |
|   jr   | 000000 |    0     |   x   |  00   |   x    |    0     |  00   |  11   |   x   |
|   j    | 000010 |    0     |   x   |  00   |   x    |    x     |  00   |  10   |   x   |

对于ALUConroll信号，由ALUOp和Func两部分信号决定，当ALUOp不为010时，ALUControl仅有ALUOp信号决定。

当ALUOp信号为010时， 可确定为R类指令，对应的ALUControl信号将由Func信号决定，具体如下：

|     Func      |   ALUControl   |
| :-----------: | :------------: |
| 100111(addiu) | 000（加运算）  |
| 100101(subu)  | 001（减运算）  |
|  100010(and)  | 010（与运算）  |
|  100011(or)   | 011（或运算）  |
| 000100(sllv)  |  100（sllv）   |
|  000000(sll)  |   101（sll）   |
|  101010(slt)  | 110(slt, slti) |



## 二、测试方案

### （一）综合程序测试

用自己设计的辅助测试工具进行测试，python脚本代码与批处理bat代码如下（这里借用了讨论区中大佬发的魔改mars~）：

```python
import subprocess
import os
from shutil import copyfile

# initialize path setting
path = "C:\\Users\\123\\Desktop\\computer organization\\test_tool2.0\\"
testfile = "test.asm"

# get code and standard output from mars(modified)
os.chdir(path)
os.system("java -jar Mars.jar nc mc CompactDataAtZero dump .text HexText code.txt >ans.txt " + testfile)
copyfile((path+"code.txt"), (path+"source\\code.txt"))
copyfile((path+"ans.txt"), (path+"report\\stdans.txt"))

# execute run.bat and get test output from I_verilog
os.chdir(path+"source")
filepath = path+"source\\run.bat"
p = subprocess.Popen(filepath, shell=True, stdout=subprocess.PIPE)
stdout, stderr = p.communicate()
copyfile(path+"source\\myout.txt", path+"report\\myans.txt")

# comare two results and give feedback
os.chdir(path+"report")
std = open("stdans.txt", "r")
test = open("myans.txt", "r")
tlin = test.readline()
while True:
    slin = std.readline()
    tlin = test.readline()
    if not tlin and slin == "\n":
        print("Accepted!")
        break
    elif not tlin:
        print("We got nothing when we expect: "+slin)
        break
    elif not slin:
        print("The answer is too much, the latest correct answer is: ")
        break
    elif slin != tlin:
        print("Wronganswer! We got"+tlin+"when we expect: "+slin)
        break
    else:
        pass

print("detailed information has been generated in report document")
input("     exit when press anything")
```

​     而仿真工具选择轻量级的Iverilog：

```python
set iverilog_path=C:\iverilog\bin;
set gtkwave_path=C:\iverilog\gtkwave\bin;
set path=%iverilog_path%%gtkwave_path%%path%

iverilog -o "test_bench.vvp" "test_bench.v" "NPC.v" "PC.v" "Controller.v" "ALU.v" "Extender.v" "LTC.v" "GRF.v" "IM.v" "mips.v" "DM.v"

(vvp -n "test_bench.vvp")> myout.txt
```

并自己构造了如下测试程序进行测试：

```python
lui $t3, 10
sw $t3, 0($0)
sw $t3, 4($0)
ori $t1, $t1, 1
addu $t1, $t1, $t2
nop
addiu $t2, $t2, 1
subu $t2, $t2, $t3
nop
lui $t1,  1
addu $0, $t2, $1
subu $t2, $0, $t3
addu $t1, $t1, $t2
nop
subu $t1, $t2, $t2
subu $t1, $t1, $t2
nop
subu $t1, $t1, $t1
ori $t1, $t1, 1
nop
subu $t2, $t2, 0
subu $t2, $t2, $t1
nop
subu $t3, $t2, $t1
subu $t2, $t3, $t1
nop
addu $t3, $t2, $t3
addu $t3, $t3, $t2
nop
lw $t2, 4($0)
addu $t3, $t2, $t1
nop
ori $t1, $t1, 1
addu $t1, $t2, $t1
nop
addiu $t2, $t2, 1
subu $t2, $t3, $t2
nop
lui $t1,  1
addu $t1, $t3, $1
nop
subu $t1, $t2, $t2
subu $t1, $t1, $t1
nop
addu $0, $t2, $1
subu $t2, $0, $t3
nop
subu $t1, $t1, $t1
ori $t1, $t1, 1
nop
subu $t2, $t2, 0
subu $t2, $t3, $t2
nop
subu $t3, $t2, $t1
subu $t2, $t4, $t3
nop
addu $t3, $t2, $t3
addu $t3, $t1, $t3
nop
lw $t2, 4($0)
addu $t3, $t1, $t2
nop
addiu $t1, $t1, 1
nop
lui $t1,  45
nop
lw $t3, 0($0)
nop
addiu $t3, $t3, 2
ori $t1, $t1, 1
nop
addu $t1, $t1, $t1
nop
subu $t1, $t1, $t3
nop
and $t1, $t1, $t2
nop
addu $t3, $t1, $t2
nop
addu $0, $t3, $t2
nop
subu $t5, $0, $1
addiu $t1, $t1, 1
nop
lui $t1,  45
nop
lw $t3, 0($0)
nop
addiu $t3, $t3, 2
ori $t1, $t1, 1
nop
addu $t1, $t1, $t1
nop
subu $t1, $t3, $t1
nop
and $t3, $t2, $1
nop
addu $t3, $t1, $t3
nop
subu $0, $t2, $t5
nop
addu $t2, $t3, $t0
nop
nop
ori $t3, 1
ori $t2, 2
addu $t2, $t2, $t2
subu $t4, $t2, $t3
addiu $t4, $t4, -1
addu $t4, $t4, $t2
or $t1, $t4, $t2
subu $t5, $t1, $t2
nop
nop
ori $t3, 4
ori $t2, 5
addu $t2, $t2, $t2
subu $t4, $t3, $t2
addiu $t4, $t4, -1
addu $t4, $t4, $t2
addiu $t4, $t4, -1
addu $t4, $t3, $t4
or $t1, $t5, $t4
subu $t5, $t2, $t1
nop
ori $t6, $t6, 1
ori $t7, $t7, 1
beq $t6, $t7, label
nop
jal num
label:
addu $t1, $t1, $t1
beq $t1, $t1, nobe
nop
num:
addu $t1, $t1, $t1
jr $ra
nop
nobe:
and $t6, $t6, $0
ori $t6, 4
sw $t6, 16($0)
lw $t1, 16($0)
ori $t7, $t7, 4
beq $t1, $t7 right2
nop
addiu $t7, $t7, 2
right2:
sw $t7, 0($0)
lw $t7, 4($0)
nop
nop
and $t6, $t6, $0
ori $t5, 5
ori $t6, 6
addiu $t6, $t6, -1
beq $t6, $t5, right_seq1
nop
addiu $t7, $t7, 2
right_seq1:
sw $t7, 0($0)
ori $0, 4
beq $0, $0, right_seql3
nop
addiu $t7 $t7, 1
right_seql3:
nop
nop
and $t6, $t6, $0
ori $t5, 5
ori $t6, 6
addiu $t6, $t6, -1
beq $t5, $t6, right_seq2
nop
addiu $t7, $t7, 2
right_seq2:
sw $t7, 0($0)
beq $0, $t1, right_seql4
nop
addiu $t7 $t7, 1
right_seql4:
nop
nop
ori $t2, $t2, 3
sw $t2, 16($0)
lw $t3, 16($0)
sw $t3, 20($0)
and $t2, $t2, $0
addiu $t2, $t2, 4
sw $t2, 0($0)
lw $t2, 0($0)
sw $t3, 0($t2)
lw $0, 0($t2)
sw $0, 4($0)

```

使用如下MIPS程序（循环计算斐波那契数列和读取存储完成计算修改）进行检验，并将DM中存储的数据与Mars存储区的数据进行比对，在DM中增加如下展示信息：

```verilog
if(read_mem) begin: display_result
				 reg [5:0] tempi;
				 for(tempi=0;tempi<32;tempi=tempi+1)
					$display("%d with data:%h\n", tempi, data_memory[tempi]);
end
```

测试程序：

```python
loop:                  #使程序循环运行
subu $t0, $t0, $t0     #初始化寄存器（循环一次后清零）
subu $s1, $s1, $s1
subu $t1, $t1, $t1
subu $t3, $t3, $t3
addi $s0, $0, 40
addi $t2, $t0, 1
for1_begin:
beq $t0, $s0, for1_end
nop
addu $t3, $t2, $0
addu $t2 $t2, $t1
addu $t1, $t3, $0
sw $t2, 0($t0)         #计算Fibonacci数并存入DataMemory
addi $t0, $t0, 4
j for1_begin
nop
for1_end:
subu $t0, $t0, $t0
lui $s1, 65535         #测试lui（$s1 = 0xffff0000）
addi $s1, $s1, 65534   # $s1 = 0xfffffffe
for2_begin:
beq $t0 , $s0, for2_end
nop
lw $t1, 0($t0)
lui $t2, 256
ori $t1, $t1, 256
or $t1, $t1, $t2       # 测试 or
and $t1, $t1, $s1      # 测试 and
sw $t1, 40($t0)
addi $t0, $t0, 4
j for2_begin
nop
for2_end:
j loop                 # 返回代码起始位置

```

该程序包含了本次设计的CPU所有支持的指令， 测试结果与Mars的标准结果相同。

## 三、思考题



#### 1. 根据你的理解，在下面给出的DM的输入示例中，地址信号addr位数为什么是[11:2]而不是[9:0]？这个addr信号又是从哪里来的？

![img](http://cscore.net.cn/assets/courseware/v1/c56b0b6aad72fb754f3712ddd75d4b42/asset-v1:Internal+B3I062410+2020_T1+type@asset+block/P4_L0_T2_5new.png)

在该DM中，Verilog中模拟的RAM应该被定义为 [31:0] memory [最大地址-1：0]， 该存储器寻址所得的数据仅能以字为单位。而MIPS指令中的寻址可以以字、半字、字节为单位，addr的最后两位不一定为0（地址不一定能被4整除）， 而在示例的DM中，不支持半字和字节为单位的寻址访问，故选用[11:2]读入数据保证读数是字对齐的（同时CPU的设计也仅包含以字为单位的读写指令）。因此，应选择[11:2]而非[9:0],该addr信号应由ALU的输出（通过基地址+偏移量的计算）取得。



#### 2.思考Verilog语言设计控制器的译码方式，给出代码示例，并尝试对比各方式的优劣。

在本次实验中，笔者选择的译码方式如例一所示该方法(P3中使用的与或门阵列相同)：

```verilog
//例1
//Opcode
`define R_type 6'b000000
`define ori    6'b001101
`define lw     6'b100011
`define sw     6'b101011
`define beq    6'b000100
`define lui    6'b001111
`define addiu  6'b001001
`define jal    6'b000011
`define j      6'b000010

//func
`define jr     6'b001000
`define addu   6'b100001
`define subu   6'b100011
`define oru    6'b100101
`define andu   6'b100100
    
//对于一位信号
assign RFWr = (Opcode==`R_type)|(Opcode==`ori)|
			  (Opcode==`lw)|(Opcode==`lui)|
			  (Opcode==`addiu)|(Opcode==`jal);
//对于两位信号
assign WRSel[0] = (Opcode==`R_type);
assign WRSel[1] = (Opcode==`jal);
```

这种方式的优点为支持的指令集较大使代码量较后一种更小，缺点为增加指令的方法更为繁琐，且如果出错，难以排查出问题。

这里给出另一种可能的译码方式为：

```verilog
always @(*) begin
    case(opcode)
        `R_type:begin
            case(function)
                `addu: begin
                    RFWr = 0;
                    WRSel = 2'b01
                    ...
                end
        `jal:
             ...
                
                    
    end
end
```

这种译码方式中， 对于每一条指令，决定其相应的控制信号。优点是与Controller的信号表一一对应，且易于增加指令，不会遗漏控制信号。缺点是如果指令集较大，代码量会大大增加。

#### 3.在相应的部件中，**reset的优先级**比其他控制信号（不包括clk信号）都要**高**，且相应的设计都是**同步复位**。清零信号reset所驱动的部件具有什么共同特点？

均属于时序模块电路，reset驱动的部件都具有存储功能（pc指令寄存器、寄存器堆、数据存储器）。对于同一运行的程序（即指令存储器IM的值保持不变），这些部件及它们存储的内容完全表征了整个CPU所处的状态。reset信号置1时，将保证整个CPU恢复初始状态。

#### 4.C语言是一种弱类型程序设计语言。C语言中不对计算结果溢出进行处理，这意味着C语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持C语言，MIPS指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi与addiu是等价的，add与addu是等价的。

对于addi与addiu：

官方指令的Operation为：

addi:

temp ← (GPR[rs]31||GPR[rs]31..0) + sign_extend(immediate)
if temp32 ≠ temp31 then
SignalException(IntegerOverflow)
else
GPR[rt] ← temp
endif

addiu:

temp ← GPR[rs] + sign_extend(immediate)
GPR[rt]← temp

对于addi中的temp信号， 在GPR的value与imm相加时，若不存在溢出，则33位与32位将保持相等（两正数相加，如果32位被进位为1，则应表示为负数而溢出，同时GPR[33]与GPR[32]不等而溢出，负数的溢出同理），故若不考虑溢出即忽略溢出时，addi与addiu等价。

add:

temp ← (GPR[rs]31||GPR[rs]31..0) + (GPR[rt]31||GPR[rt]31..0)
if temp32 ≠ temp31 then
SignalException(IntegerOverflow)
else
GPR[rd] ← temp
endif

addu:

temp ← GPR[rs] + GPR[rt]
GPR[rd] ← temp

对于add，若两个值一正一负，则不会产生溢出；若同为正数，则temp[32]、temp[31]均为0， 若产生溢出，则temp[31]进位为1， 此时temp[31]与temp[32]不等；若同为负数， 则当后续位在temp[31]不产生进位时，结果溢出，此时temp[31]为0，temp[32]为[1]；综上所述，在temp32 ≠ temp31时，不出现溢出，执行else分支与addu的结果相同。故若不考虑溢出即忽略溢出时，add与addu等价。

#### 5.根据自己的设计说明单周期处理器的优缺点。

优点：结构简单（我们最先尝试搭建的CPU）， 在教学中最易上手，是之后更复杂的多周期CPU或流水线CPU的基础。单条令执行速度快（各个部件间的连接或为直接连接，或经过MUX选择连接，不存在较大的延迟或时序性的缓存）。

缺点：直接决定处理器速度的时钟最小周期取决于执行时间最长的指令（如lw的数据通路需要经历IM-GRF-ALU-DM-GRF）,时钟周期必须大于信号稳定时间与数据通路经过所有元件的时间总和。从每个部件的角度来看，每个部件在一个周期中仅有在指令的信号通过该部件时被使用，大部分时间处于闲置状态，即从利用率的角度而言存在较大的浪费。对于一般的一长串指令执行速度较慢。



